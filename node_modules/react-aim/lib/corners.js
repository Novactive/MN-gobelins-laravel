'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.corners = corners;
exports.boundaries = boundaries;

var _aim = require('./aim');

function inside(source, targetMin, targetMax) {
  if (source >= targetMin && source <= targetMax) return 0;else if (source > targetMin) return -1;else return 1;
}

function corners(source, target) {
  source = { left: source.pageX, top: source.pageY };
  target = target.getBoundingClientRect();

  var ver = void 0,
      hor = void 0;

  hor = inside(source.left, target.left, target.left + target.width);
  ver = inside(source.top, target.top, source.top + target.height);

  if (hor === -1 && ver === -1) return ['top-right', 'bottom-left'];
  if (hor === -1 && ver === 0) return ['top-right', 'bottom-right'];
  if (hor === -1 && ver === 1) return ['top-left', 'bottom-right'];

  if (hor === 0 && ver === -1) return ['bottom-right', 'bottom-left'];
  if (hor === 0 && ver === 0) return [];
  if (hor === 0 && ver === 1) return ['top-left', 'top-right'];

  if (hor === 1 && ver === -1) return ['bottom-right', 'top-left'];
  if (hor === 1 && ver === 0) return ['bottom-left', 'top-left'];
  if (hor === 1 && ver === 1) return ['bottom-left', 'top-right'];
}

function boundaries(corners, source, target) {
  var adjustment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (target instanceof HTMLElement || target instanceof SVGElement) {
    target = target.getBoundingClientRect();
  }

  if (!source) return [];else if (source instanceof Event) {
    source = {
      left: source.pageX,
      top: source.pageY
    };
  } else if (source.x) {
    source = {
      left: source.x,
      top: source.y
    };
  }

  var tolerance = adjustment !== false ? Math.round(adjustment / 10) * 1.5 : 0;
  var position = {
    left: target.left - tolerance,
    top: target.top - tolerance,
    width: target.width + tolerance * 2,
    height: target.height + tolerance * 2
  };

  var doc = document.documentElement;
  var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
  var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);

  var first = true;
  var positions = [];
  corners.forEach(function (corner) {
    switch (corner) {
      case 'top-right':
        if (first) positions.push({ x: target.left + target.width + left, y: target.top + top });
        positions.push({ x: position.left + position.width + left, y: position.top + top });
        if (!first) positions.push({ x: target.left + target.width + left, y: target.top + top });
        break;
      case 'top-left':
        if (first) positions.push({ x: target.left + left, y: target.top + top });
        positions.push({ x: position.left + left, y: position.top + top });
        if (!first) positions.push({ x: target.left + left, y: target.top + top });
        break;
      case 'bottom-right':
        if (first) positions.push({ x: target.left + target.width + left, y: target.top + target.height + top });
        positions.push({ x: position.left + position.width + left, y: position.top + position.height + top });
        if (!first) positions.push({ x: target.left + target.width + left, y: target.top + target.height + top });
        break;
      case 'bottom-left':
        if (first) positions.push({ x: target.left + left, y: target.top + target.height + top });
        positions.push({ x: position.left + left, y: position.top + position.height + top });
        if (!first) positions.push({ x: target.left + left, y: target.top + target.height + top });
        break;
    }
    if (first) {
      positions.push({ x: source.left, y: source.top });
    }
    first = false;
  });

  if (adjustment === false) {
    var be = (0, _aim.bullseye)(corners, positions, { x: source.left, y: source.top });
    if (be) {
      var dist = Math.round((0, _aim.distance)({ x: source.left, y: source.top }, be));
      return boundaries(corners, source, target, dist);
    }
  }

  return positions;
}

exports.default = corners;