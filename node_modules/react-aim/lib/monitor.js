'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _aim = require('./aim');

var _aim2 = _interopRequireDefault(_aim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scrollPosition() {
  var scrollTop = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
  var scrollLeft = document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;

  return { scrollTop: scrollTop, scrollLeft: scrollLeft };
}

function mousePosition(event) {
  var sPos = scrollPosition();

  var x = document.all ? event.clientX + sPos.scrollLeft : event.pageX;
  var y = document.all ? event.clientY + sPos.scrollTop : event.pageY;

  return { x: x, y: y };
}

var Monitor = function () {
  function Monitor() {
    var _this = this;

    _classCallCheck(this, Monitor);

    this.targets = [];

    this.handleMouseMove = function (e) {
      _this.mousePosition = mousePosition(e);
      _this.checkAim(e);
      _this.prevMousePosition = _this.mousePosition;
    };

    if (typeof document !== 'undefined' && document.addEventListener) {
      document.addEventListener('mousemove', this.handleMouseMove);
    }
  }

  _createClass(Monitor, [{
    key: 'checkAim',
    value: function checkAim(e) {
      var _this2 = this;

      this.targets.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            target = _ref2[0],
            element = _ref2[1];

        var distance = (0, _aim2.default)(e, _this2.mousePosition, _this2.prevMousePosition, element, target.aiming);
        if (distance !== true && distance) {
          target.triggerAimMove(distance);
        } else if (!distance) {
          target.triggerAimStop();
        }
      });
    }
  }, {
    key: 'addTarget',
    value: function addTarget(target) {
      this.targets.push([target, _reactDom2.default.findDOMNode(target)]);
    }
  }, {
    key: 'removeTarget',
    value: function removeTarget(target) {
      var index = void 0;
      for (var i = 0, len = this.targets.length; i < len; ++i) {
        if (this.targets[i][0] === target) {
          index = i;
          break;
        }
      }
      return this.targets = [].concat(_toConsumableArray(this.targets.slice(0, index)), _toConsumableArray(this.targets.slice(index + 1)));
    }
  }, {
    key: 'hasAimedTarget',
    value: function hasAimedTarget() {
      for (var i = 0, len = this.targets.length; i < len; ++i) {
        if (this.targets[i][0].aiming) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'sourceIsChildrenOfAimedTarget',
    value: function sourceIsChildrenOfAimedTarget(source) {
      var result = false;
      this.aimedTargets.forEach(function (target) {
        if (target.aiming && target.hasChildrenSource(source)) result = true;
      });
      return result;
    }
  }, {
    key: 'requestMouseEnter',
    value: function requestMouseEnter(source) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.hasAimedTarget() && !_this3.sourceIsChildrenOfAimedTarget(source)) {
          _this3.lastEnterRequest = source;
          return reject();
        }
        _this3.lastEnterRequest = null;
        return resolve();
      });
    }
  }, {
    key: 'requestMouseLeave',
    value: function requestMouseLeave(source) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (source.hasChildrenOver() || source.hasChildrenAimed()) {
            _this4.lastLeaveRequest = source;
            return reject();
          }
          _this4.lastLeaveRequest = null;
          return resolve();
        }, 0);
      });
    }
  }, {
    key: 'mouseOver',
    value: function mouseOver(event, component) {
      if (component._isMounted) {
        var mPos = mousePosition(event);
        var sPos = scrollPosition();

        var rect = _reactDom2.default.findDOMNode(component).getBoundingClientRect();
        var left = rect.left + sPos.scrollLeft;
        var top = rect.top + sPos.scrollTop;

        return mPos.x >= left && mPos.x <= left + rect.width && mPos.y >= top && mPos.y <= top + rect.height;
      }
      return false;
    }
  }, {
    key: 'aimStopped',
    value: function aimStopped() {
      var _this5 = this;

      if (this.lastEnterRequest) {
        if (this.mouseOver({ pageX: this.mousePosition.x, pageY: this.mousePosition.y }, this.lastEnterRequest)) {
          var enterSource = this.lastEnterRequest;
          this.requestMouseEnter(enterSource).then(function () {
            _this5.lastEnterRequest = null;
            enterSource.forceMouseEnter();
          }).catch(function () {
            return null;
          });
        }
      }

      if (this.lastLeaveRequest) {
        if (!this.mouseOver({ pageX: this.mousePosition.x, pageY: this.mousePosition.y }, this.lastLeaveRequest)) {
          var leaveSource = this.lastLeaveRequest;
          this.requestMouseLeave(this.lastLeaveRequest).then(function () {
            _this5.lastLeaveRequest = null;
            leaveSource.forceMouseLeave();
          }).catch(function () {
            return null;
          });
        }
      }
    }
  }, {
    key: 'aimedTargets',
    get: function get() {
      var targets = [];
      for (var i = 0, len = this.targets.length; i < len; ++i) {
        if (this.targets[i][0].aiming) {
          targets.push(this.targets[i][0]);
        }
      }
      return targets;
    }
  }]);

  return Monitor;
}();

exports.default = new Monitor();